#include "vdbe-gen.h"
char const* const VdbeCompiledQueryTextQ1 = "select\n    l_returnflag,\n    l_linestatus,\n    sum(l_quantity) as sum_qty,\n    sum(l_extendedprice) as sum_base_price,\n    sum(l_extendedprice*(1-l_discount)) as sum_disc_price,\n    sum(l_extendedprice*(1-l_discount)*(1+l_tax)) as sum_charge,\n    avg(l_quantity) as avg_qty,\n    avg(l_extendedprice) as avg_price,\n    avg(l_discount) as avg_disc,\n    count(*) as count_order\nfrom\n    lineitem\nwhere\n    l_shipdate <= '1998-12-01'\ngroup by\n    l_returnflag,\n    l_linestatus\norder by\n    l_returnflag,\n    l_linestatus;";
int VdbeCompiledQueryCodeQ1(Vdbe *p) {
static void* const labels[]={&&L0,&&L1,&&L2,&&L3,&&L4,&&L5,&&L6,&&L7,&&L8,&&L9,&&L10,&&L11,&&L12,&&L13,&&L14,&&L15,&&L16,&&L17,&&L18,&&L19,&&L20,&&L21,&&L22,&&L23,&&L24,&&L25,&&L26,&&L27,&&L28,&&L29,&&L30,&&L31,&&L32,&&L33,&&L34,&&L35,&&L36,&&L37,&&L38,&&L39,&&L40,&&L41,&&L42,&&L43,&&L44,&&L45,&&L46,&&L47,&&L48,&&L49,&&L50,&&L51,&&L52,&&L53,&&L54,&&L55,&&L56,&&L57,&&L58,&&L59,&&L60,&&L61,&&L62,&&L63,&&L64,&&L65,&&L66,&&L67,&&L68,&&L69,&&L70,&&L71,&&L72,&&L73,&&L74,&&L75,&&L76,&&L77,&&L78,&&L79,&&L80,&&L81,&&L82,&&L83,&&L84,&&L85,&&L86,&&L87,&&L88,&&Lend};
 void * target; int rc = SQLITE_OK; sqlite3 *db = p->db; u8 resetSchemaOnFault = 0; u8 encoding = ENC(db); int iCompare = 0; unsigned nVmStep = 0; unsigned nProgressLimit = 0; Mem *aMem = p->aMem; Mem *pIn1 = 0; Mem *pIn2 = 0; Mem *pIn3 = 0; Mem *pOut = 0; int *aPermute = 0; i64 lastRowid = db->lastRowid; assert( p->magic==VDBE_MAGIC_RUN ); sqlite3VdbeEnter(p); if( p->rc==SQLITE_NOMEM ){ goto no_mem; } assert( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_BUSY ); assert( p->bIsReader || p->readOnly!=0 ); p->rc = SQLITE_OK; p->iCurrentTime = 0; assert( p->explain==0 ); p->pResultSet = 0; db->busyHandler.nBusy = 0; if( db->u1.isInterrupted ) goto abort_due_to_interrupt; sqlite3VdbeIOTraceSql(p); goto *labels[p->pc]; 
L0:
do {{ if( 84 ) goto L84; } } while(0);
L1:
do {} while(0);
L2:
do {{ VdbeCursor *pCx; assert( 2>=0 ); assert( 6>=0 ); pCx = allocateCursor(p, 2, 6, -1, CURTYPE_SORTER); if( pCx==0 ) goto no_mem; pCx->pKeyInfo = p->aOp[2].p4.pKeyInfo; assert( pCx->pKeyInfo->db==db ); assert( pCx->pKeyInfo->enc==ENC(db) ); rc = sqlite3VdbeSorterInit(db, 0, pCx); if( rc ) goto abort_due_to_error; } } while(0);
L3:
do {{ pOut = out2Prerelease(p, 16); pOut->u.i = 0; } } while(0);
L4:
do {{ pOut = out2Prerelease(p, 15); pOut->u.i = 0; } } while(0);
L5:
do {{ int cnt; u16 nullFlag; pOut = out2Prerelease(p, 19); cnt = 20-19; assert( 20<=(p->nMem-p->nCursor) ); pOut->flags = nullFlag = 0 ? (MEM_Null|MEM_Cleared) : MEM_Null; while( cnt>0 ){ pOut++; memAboutToChange(p, pOut); sqlite3VdbeMemSetNull(pOut); pOut->flags = nullFlag; cnt--; } } } while(0);
L6:
do {{ assert( 18>0 && 18<=(p->nMem-p->nCursor) ); pIn1 = &aMem[18]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(6); REGISTER_TRACE(18, pIn1); goto L81; } } while(0);
L7:
do {{ int nField; KeyInfo *pKeyInfo; int p2; int iDb; int wrFlag; Btree *pX; VdbeCursor *pCur; Db *pDb; if (54 == OP_ReopenIdx) { assert( 0==0 || 0==OPFLAG_SEEKEQ ); assert( -14==P4_KEYINFO ); pCur = p->apCsr[0]; if( pCur && pCur->pgnoRoot==(u32)2 ){ assert( pCur->iDb==0 ); goto open_cursor_set_hints7; } } assert( 54==OP_OpenWrite || 0==0 || 0==OPFLAG_SEEKEQ ); assert( p->bIsReader ); assert( 54==OP_OpenRead || 54==OP_ReopenIdx || p->readOnly==0 ); if( p->expired ){ rc = SQLITE_ABORT_ROLLBACK; goto abort_due_to_error; } nField = 0; pKeyInfo = 0; p2 = 2; iDb = 0; assert( iDb>=0 && iDb<db->nDb ); assert( DbMaskTest(p->btreeMask, iDb) ); pDb = &db->aDb[iDb]; pX = pDb->pBt; assert( pX!=0 ); if( 54==OP_OpenWrite ){ assert( OPFLAG_FORDELETE==BTREE_FORDELETE ); wrFlag = BTREE_WRCSR | (0 & OPFLAG_FORDELETE); assert( sqlite3SchemaMutexHeld(db, iDb, 0) ); if( pDb->pSchema->file_format < p->minWriteFileFormat ){ p->minWriteFileFormat = pDb->pSchema->file_format; } }else{ wrFlag = 0; } if( 0 & OPFLAG_P2ISREG ){ assert( p2>0 ); assert( p2<=(p->nMem-p->nCursor) ); pIn2 = &aMem[p2]; assert( memIsValid(pIn2) ); assert( (pIn2->flags & MEM_Int)!=0 ); sqlite3VdbeMemIntegerify(pIn2); p2 = (int)pIn2->u.i; assert( p2>=2 ); } if( -14==P4_KEYINFO ){ pKeyInfo = p->aOp[7].p4.pKeyInfo; assert( pKeyInfo->enc==ENC(db) ); assert( pKeyInfo->db==db ); nField = pKeyInfo->nField+pKeyInfo->nXField; }else if( -14==P4_INT32 ){ nField = 11; } assert( 0>=0 ); assert( nField>=0 ); testcase( nField==0 ); pCur = allocateCursor(p, 0, nField, iDb, CURTYPE_BTREE); if( pCur==0 ) goto no_mem; pCur->nullRow = 1; pCur->isOrdered = 1; pCur->pgnoRoot = p2; rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor); pCur->pKeyInfo = pKeyInfo; pCur->isTable = -14!=P4_KEYINFO; open_cursor_set_hints7: assert( OPFLAG_BULKCSR==BTREE_BULKLOAD ); assert( OPFLAG_SEEKEQ==BTREE_SEEK_EQ ); testcase( 0 & OPFLAG_BULKCSR ); sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (0 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ))); if( rc ) goto abort_due_to_error; } } while(0);
L8:
do {{ VdbeCursor *pC; BtCursor *pCrsr; int res; if (108 != OP_Rewind) { p->aCounter[SQLITE_STMTSTATUS_SORT]++; } assert( 0>=0 && 0<p->nCursor ); pC = p->apCsr[0]; assert( pC!=0 ); assert( isSorter(pC)==(108==OP_SorterSort) ); res = 1; if( isSorter(pC) ){ rc = sqlite3VdbeSorterRewind(pC, &res); }else{ assert( pC->eCurType==CURTYPE_BTREE ); pCrsr = pC->uc.pCursor; assert( pCrsr ); rc = sqlite3BtreeFirst(pCrsr, &res); pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; } if( rc ) goto abort_due_to_error; pC->nullRow = (u8)res; assert( 24>0 && 24<p->nOp ); VdbeBranchTaken(res!=0,2); if( res ) goto L24; } } while(0);
L9:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[9], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L10:
do {{ int res; char affinity; u16 flags1; u16 flags3; pIn1 = &aMem[24]; pIn3 = &aMem[23]; flags1 = pIn1->flags; flags3 = pIn3->flags; if( (flags1 | flags3)&MEM_Null ){ if( 83 & SQLITE_NULLEQ ){ assert( 80==OP_Eq || 80==OP_Ne ); assert( (flags1 & MEM_Cleared)==0 ); assert( (83 & SQLITE_JUMPIFNULL)==0 ); if( (flags1&MEM_Null)!=0 && (flags3&MEM_Null)!=0 && (flags3&MEM_Cleared)==0 ){ res = 0; }else{ res = 1; } }else{ if( 83 & SQLITE_STOREP2 ){ pOut = &aMem[23]; memAboutToChange(p, pOut); MemSetTypeFlag(pOut, MEM_Null); REGISTER_TRACE(23, pOut); }else{ VdbeBranchTaken(2,3); if( 83 & SQLITE_JUMPIFNULL ){ goto L23; } } break; } }else{ affinity = 83 & SQLITE_AFF_MASK; if( affinity>=SQLITE_AFF_NUMERIC ){ if( (flags1 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){ applyNumericAffinity(pIn1,0); } if( (flags3 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){ applyNumericAffinity(pIn3,0); } }else if( affinity==SQLITE_AFF_TEXT ){ if( (flags1 & MEM_Str)==0 && (flags1 & (MEM_Int|MEM_Real))!=0 ){ testcase( pIn1->flags & MEM_Int ); testcase( pIn1->flags & MEM_Real ); sqlite3VdbeMemStringify(pIn1, encoding, 1); testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) ); flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask); } if( (flags3 & MEM_Str)==0 && (flags3 & (MEM_Int|MEM_Real))!=0 ){ testcase( pIn3->flags & MEM_Int ); testcase( pIn3->flags & MEM_Real ); sqlite3VdbeMemStringify(pIn3, encoding, 1); testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) ); flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask); } } assert( -4==P4_COLLSEQ || p->aOp[10].p4.pColl==0 ); if( flags1 & MEM_Zero ){ sqlite3VdbeMemExpandBlob(pIn1); flags1 &= ~MEM_Zero; } if( flags3 & MEM_Zero ){ sqlite3VdbeMemExpandBlob(pIn3); flags3 &= ~MEM_Zero; } res = sqlite3MemCompare(pIn3, pIn1, p->aOp[10].p4.pColl); } switch( 80 ){ case OP_Eq: res = res==0; break; case OP_Ne: res = res!=0; break; case OP_Lt: res = res<0; break; case OP_Le: res = res<=0; break; case OP_Gt: res = res>0; break; default: res = res>=0; break; } assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) ); pIn1->flags = flags1; assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) ); pIn3->flags = flags3; if( 83 & SQLITE_STOREP2 ){ pOut = &aMem[23]; memAboutToChange(p, pOut); MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = res; REGISTER_TRACE(23, pOut); }else{ VdbeBranchTaken(res!=0, (83 & SQLITE_NULLEQ)?2:3); if( res ){ goto L23; } } } } while(0);
L11:
L12:
L13:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[11], 3); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L14:
do {{ pIn1 = &aMem[27]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } } while(0);
L15:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[15], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L16:
do {{ pIn1 = &aMem[28]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } } while(0);
L17:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[17], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L18:
do {{ pIn1 = &aMem[29]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } } while(0);
L19:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[19], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L20:
do {{ pIn1 = &aMem[30]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } } while(0);
L21:
do {{ u8 *zNewRecord; Mem *pRec; u64 nData; int nHdr; i64 nByte; i64 nZero; int nVarint; u32 serial_type; Mem *pData0; Mem *pLast; int nField; char *zAffinity; int file_format; int i; int j; u32 len; nData = 0; nHdr = 0; nZero = 0; nField = 25; zAffinity = 0; assert( nField>0 && 6>0 && 6+nField<=(p->nMem-p->nCursor)+1 ); pData0 = &aMem[nField]; nField = 6; pLast = &pData0[nField-1]; file_format = p->minWriteFileFormat; assert( 23<25 || 23>=25+6 ); pOut = &aMem[23]; memAboutToChange(p, pOut); assert( pData0<=pLast ); if( zAffinity ){ pRec = pData0; do{ applyAffinity(pRec++, *(zAffinity++), encoding); assert( zAffinity[0]==0 || pRec<=pLast ); }while( zAffinity[0] ); } pRec = pLast; do{ assert( memIsValid(pRec) ); pRec->uTemp = serial_type = sqlite3VdbeSerialType(pRec, file_format, &len); if( pRec->flags & MEM_Zero ){ if( nData ){ if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem; }else{ nZero += pRec->u.nZero; len -= pRec->u.nZero; } } nData += len; testcase( serial_type==127 ); testcase( serial_type==128 ); nHdr += serial_type<=127 ? 1 : sqlite3VarintLen(serial_type); }while( (--pRec)>=pData0 ); testcase( nHdr==126 ); testcase( nHdr==127 ); if( nHdr<=126 ){ nHdr += 1; }else{ nVarint = sqlite3VarintLen(nHdr); nHdr += nVarint; if( nVarint<sqlite3VarintLen(nHdr) ) nHdr++; } nByte = nHdr+nData; if( nByte+nZero>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } if( sqlite3VdbeMemClearAndResize(pOut, (int)nByte) ){ goto no_mem; } zNewRecord = (u8 *)pOut->z; i = putVarint32(zNewRecord, nHdr); j = nHdr; assert( pData0<=pLast ); pRec = pData0; do{ serial_type = pRec->uTemp; i += putVarint32(&zNewRecord[i], serial_type); j += sqlite3VdbeSerialPut(&zNewRecord[j], pRec, serial_type); }while( (++pRec)<=pLast ); assert( i==nHdr ); assert( j==nByte ); assert( 23>0 && 23<=(p->nMem-p->nCursor) ); pOut->n = (int)nByte; pOut->flags = MEM_Blob; if( nZero ){ pOut->u.nZero = nZero; pOut->flags |= MEM_Zero; } pOut->enc = SQLITE_UTF8; REGISTER_TRACE(23, pOut); UPDATE_MAX_BLOBSIZE(pOut); } } while(0);
L22:
do {{ VdbeCursor *pC; int nKey; const char *zKey; assert( 2>=0 && 2<p->nCursor ); pC = p->apCsr[2]; assert( pC!=0 ); assert( isSorter(pC)==(109==OP_SorterInsert) ); pIn2 = &aMem[23]; assert( pIn2->flags & MEM_Blob ); if( 0 & OPFLAG_NCHANGE ) p->nChange++; assert( pC->eCurType==CURTYPE_BTREE || 109==OP_SorterInsert ); assert( pC->isTable==0 ); rc = ExpandBlob(pIn2); if( rc ) goto abort_due_to_error; if( 109==OP_SorterInsert ){ rc = sqlite3VdbeSorterWrite(pC, pIn2); }else{ nKey = pIn2->n; zKey = pIn2->z; rc = sqlite3BtreeInsert(pC->uc.pCursor, zKey, nKey, "", 0, 0, 0, ((0 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0) ); assert( pC->deferredMoveto==0 ); pC->cacheStatus = CACHE_STALE; } if( rc) goto abort_due_to_error; } } while(0);
L23:
do {{ VdbeCursor *pC; int res; if (7 == OP_SorterNext) { pC = p->apCsr[0]; assert( isSorter(pC) ); res = 0; rc = sqlite3VdbeSorterNext(db, pC, &res); goto next_tail23; } if (7 == OP_PrevIfOpen || 7 == OP_NextIfOpen) { if( p->apCsr[0]==0 ) break; } assert( 0>=0 && 0<p->nCursor ); assert( 1<ArraySize(p->aCounter) ); pC = p->apCsr[0]; res = 0; assert( pC!=0 ); assert( pC->deferredMoveto==0 ); assert( pC->eCurType==CURTYPE_BTREE ); assert( res==0 || (res==1 && pC->isTable==0) ); testcase( res==1 ); assert( 7!=OP_Next || p->aOp[23].p4.xAdvance==sqlite3BtreeNext ); assert( 7!=OP_Prev || p->aOp[23].p4.xAdvance==sqlite3BtreePrevious ); assert( 7!=OP_NextIfOpen || p->aOp[23].p4.xAdvance==sqlite3BtreeNext ); assert( 7!=OP_PrevIfOpen || p->aOp[23].p4.xAdvance==sqlite3BtreePrevious); assert( 7!=OP_Next || 7!=OP_NextIfOpen || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found); assert( 7!=OP_Prev || 7!=OP_PrevIfOpen || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE || pC->seekOp==OP_Last ); rc = p->aOp[23].p4.xAdvance(pC->uc.pCursor, &res); next_tail23: pC->cacheStatus = CACHE_STALE; VdbeBranchTaken(res==0,2); if( rc ) goto abort_due_to_error; if( res==0 ){ pC->nullRow = 0; p->aCounter[1]++; if( db->u1.isInterrupted ) goto abort_due_to_interrupt; goto L9; }else{ pC->nullRow = 1; } if( db->u1.isInterrupted ) goto abort_due_to_interrupt; } } while(0);
L24:
do {{ assert( 0>=0 && 0<p->nCursor ); sqlite3VdbeFreeCursor(p, p->apCsr[0]); p->apCsr[0] = 0; } } while(0);
L25:
do {{ VdbeCursor *pCx; assert( 3>=0 ); assert( 6>=0 ); pCx = allocateCursor(p, 3, 6, -1, CURTYPE_PSEUDO); if( pCx==0 ) goto no_mem; pCx->nullRow = 1; pCx->uc.pseudoTableReg = 23; pCx->isTable = 1; assert( 0==0 ); } } while(0);
L26:
do {{ VdbeCursor *pC; BtCursor *pCrsr; int res; if (106 != OP_Rewind) { p->aCounter[SQLITE_STMTSTATUS_SORT]++; } assert( 2>=0 && 2<p->nCursor ); pC = p->apCsr[2]; assert( pC!=0 ); assert( isSorter(pC)==(106==OP_SorterSort) ); res = 1; if( isSorter(pC) ){ rc = sqlite3VdbeSorterRewind(pC, &res); }else{ assert( pC->eCurType==CURTYPE_BTREE ); pCrsr = pC->uc.pCursor; assert( pCrsr ); rc = sqlite3BtreeFirst(pCrsr, &res); pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; } if( rc ) goto abort_due_to_error; pC->nullRow = (u8)res; assert( 83>0 && 83<p->nOp ); VdbeBranchTaken(res!=0,2); if( res ) goto L83; } } while(0);
L27:
do {{ VdbeCursor *pC; pOut = &aMem[23]; pC = p->apCsr[2]; assert( isSorter(pC) ); rc = sqlite3VdbeSorterRowkey(pC, pOut); assert( rc!=SQLITE_OK || (pOut->flags & MEM_Blob) ); assert( 2>=0 && 2<p->nCursor ); if( rc ) goto abort_due_to_error; p->apCsr[3]->cacheStatus = CACHE_STALE; } } while(0);
L28:
L29:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[28], 2); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L30:
do {{ int n; int i; int p1; int p2; const KeyInfo *pKeyInfo; int idx; CollSeq *pColl; int bRev; if( (0 & OPFLAG_PERMUTE)==0 ) aPermute = 0; n = 2; pKeyInfo = p->aOp[30].p4.pKeyInfo; assert( n>0 ); assert( pKeyInfo!=0 ); p1 = 19; p2 = 21; for(i=0; i<n; i++){ idx = aPermute ? aPermute[i] : i; assert( memIsValid(&aMem[p1+idx]) ); assert( memIsValid(&aMem[p2+idx]) ); REGISTER_TRACE(p1+idx, &aMem[p1+idx]); REGISTER_TRACE(p2+idx, &aMem[p2+idx]); assert( i<pKeyInfo->nField ); pColl = pKeyInfo->aColl[i]; bRev = pKeyInfo->aSortOrder[i]; iCompare = sqlite3MemCompare(&aMem[p1+idx], &aMem[p2+idx], pColl); if( iCompare ){ if( bRev ) iCompare = -iCompare; break; } } aPermute = 0; } } while(0);
L31:
do {{ if( iCompare<0 ){ VdbeBranchTaken(0,3); goto L32; }else if( iCompare==0 ){ VdbeBranchTaken(1,3); goto L36; }else{ VdbeBranchTaken(2,3); goto L32; } } } while(0);
L32:
do {{ int n; int p1; int p2; n = 2; p1 = 21; p2 = 19; assert( n>0 && p1>0 && p2>0 ); assert( p1+n<=p2 || p2+n<=p1 ); pIn1 = &aMem[p1]; pOut = &aMem[p2]; do{ assert( pOut<=&aMem[(p->nMem-p->nCursor)] ); assert( pIn1<=&aMem[(p->nMem-p->nCursor)] ); assert( memIsValid(pIn1) ); memAboutToChange(p, pOut); sqlite3VdbeMemMove(pOut, pIn1); Deephemeralize(pOut); REGISTER_TRACE(p2++, pOut); pIn1++; pOut++; }while( --n ); } } while(0);
L33:
do {{ assert( 17>0 && 17<=(p->nMem-p->nCursor) ); pIn1 = &aMem[17]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(33); REGISTER_TRACE(17, pIn1); goto L68; } } while(0);
L34:
do {{ pIn1 = &aMem[16]; assert( pIn1->flags&MEM_Int ); VdbeBranchTaken( pIn1->u.i>0, 2); if( pIn1->u.i>0 ){ pIn1->u.i -= 0; goto L83; } } } while(0);
L35:
do {{ assert( 18>0 && 18<=(p->nMem-p->nCursor) ); pIn1 = &aMem[18]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(35); REGISTER_TRACE(18, pIn1); goto L81; } } while(0);
L36:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[36], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L37:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[37]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 3>0 && 3<=(p->nMem-p->nCursor) ); assert( n==0 || (25>0 && 25+n<=(p->nMem-p->nCursor)+1) ); assert( 3<25 || 3>=25+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)37; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[3]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[25+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[37-1].opcode==OP_CollSeq ); i = p->aOp[37-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L38:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[38], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L39:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[39]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 4>0 && 4<=(p->nMem-p->nCursor) ); assert( n==0 || (26>0 && 26+n<=(p->nMem-p->nCursor)+1) ); assert( 4<26 || 4>=26+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)39; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[4]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[26+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[39-1].opcode==OP_CollSeq ); i = p->aOp[39-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L40:
L41:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[40], 2); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L42:
do {{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[34]; type1 = numericType(pIn1); pIn2 = &aMem[33]; type2 = numericType(pIn2); pOut = &aMem[32]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null42; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 90 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp42_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp42_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp42_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null42; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp42_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null42; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp42_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 90 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null42; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null42; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null42; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null42: sqlite3VdbeMemSetNull(pOut); } } while(0);
L43:
do {{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[32]; type1 = numericType(pIn1); pIn2 = &aMem[31]; type2 = numericType(pIn2); pOut = &aMem[27]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null43; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 91 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp43_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp43_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp43_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null43; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp43_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null43; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp43_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 91 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null43; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null43; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null43; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null43: sqlite3VdbeMemSetNull(pOut); } } while(0);
L44:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[44]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 5>0 && 5<=(p->nMem-p->nCursor) ); assert( n==0 || (27>0 && 27+n<=(p->nMem-p->nCursor)+1) ); assert( 5<27 || 5>=27+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)44; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[5]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[27+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[44-1].opcode==OP_CollSeq ); i = p->aOp[44-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L45:
L46:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[45], 2); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L47:
do {{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[35]; type1 = numericType(pIn1); pIn2 = &aMem[33]; type2 = numericType(pIn2); pOut = &aMem[34]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null47; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 90 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp47_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp47_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp47_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null47; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp47_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null47; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp47_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 90 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null47; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null47; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null47; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null47: sqlite3VdbeMemSetNull(pOut); } } while(0);
L48:
do {{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[34]; type1 = numericType(pIn1); pIn2 = &aMem[31]; type2 = numericType(pIn2); pOut = &aMem[32]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null48; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 91 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp48_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp48_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp48_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null48; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp48_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null48; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp48_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 91 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null48; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null48; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null48; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null48: sqlite3VdbeMemSetNull(pOut); } } while(0);
L49:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[49], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L50:
do {{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[31]; type1 = numericType(pIn1); pIn2 = &aMem[33]; type2 = numericType(pIn2); pOut = &aMem[34]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null50; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 89 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp50_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp50_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp50_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null50; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp50_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null50; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp50_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 89 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null50; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null50; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null50; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null50: sqlite3VdbeMemSetNull(pOut); } } while(0);
L51:
do {{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[34]; type1 = numericType(pIn1); pIn2 = &aMem[32]; type2 = numericType(pIn2); pOut = &aMem[28]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null51; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 91 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp51_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp51_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp51_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null51; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp51_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null51; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp51_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 91 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null51; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null51; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null51; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null51: sqlite3VdbeMemSetNull(pOut); } } while(0);
L52:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[52]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 6>0 && 6<=(p->nMem-p->nCursor) ); assert( n==0 || (28>0 && 28+n<=(p->nMem-p->nCursor)+1) ); assert( 6<28 || 6>=28+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)52; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[6]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[28+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[52-1].opcode==OP_CollSeq ); i = p->aOp[52-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L53:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[53], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L54:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[54]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 7>0 && 7<=(p->nMem-p->nCursor) ); assert( n==0 || (29>0 && 29+n<=(p->nMem-p->nCursor)+1) ); assert( 7<29 || 7>=29+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)54; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[7]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[29+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[54-1].opcode==OP_CollSeq ); i = p->aOp[54-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L55:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[55], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L56:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[56]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 8>0 && 8<=(p->nMem-p->nCursor) ); assert( n==0 || (30>0 && 30+n<=(p->nMem-p->nCursor)+1) ); assert( 8<30 || 8>=30+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)56; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[8]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[30+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[56-1].opcode==OP_CollSeq ); i = p->aOp[56-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L57:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[57], 1); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L58:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[58]; if ( op->p4type==P4_FUNCDEF ) { int n = 1; assert( 9>0 && 9<=(p->nMem-p->nCursor) ); assert( n==0 || (30>0 && 30+n<=(p->nMem-p->nCursor)+1) ); assert( 9<30 || 9>=30+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)58; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[9]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[30+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[58-1].opcode==OP_CollSeq ); i = p->aOp[58-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L59:
do {{ int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[59]; if ( op->p4type==P4_FUNCDEF ) { int n = 0; assert( 10>0 && 10<=(p->nMem-p->nCursor) ); assert( n==0 || (0>0 && 0+n<=(p->nMem-p->nCursor)+1) ); assert( 10<0 || 10>=0+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)59; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type=P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[10]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[0+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert(p->aOp[59-1].opcode==OP_CollSeq ); i = p->aOp[59-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } } while(0);
L60:
L61:
do { rc = sqlite3VdbeGetColumn(p, &p->aOp[60], 2); if (rc != SQLITE_OK) { if (rc == SQLITE_TOOBIG) { goto too_big; } else if (rc == SQLITE_NOMEM_BKPT) { goto no_mem; } else { goto abort_due_to_error; } } } while(0);
L62:
do {{ pOut = out2Prerelease(p, 15); pOut->u.i = 1; } } while(0);
L63:
do {{ VdbeCursor *pC; int res; if (3 == OP_SorterNext) { pC = p->apCsr[2]; assert( isSorter(pC) ); res = 0; rc = sqlite3VdbeSorterNext(db, pC, &res); goto next_tail63; } if (3 == OP_PrevIfOpen || 3 == OP_NextIfOpen) { if( p->apCsr[2]==0 ) break; } assert( 2>=0 && 2<p->nCursor ); assert( 0<ArraySize(p->aCounter) ); pC = p->apCsr[2]; res = 0; assert( pC!=0 ); assert( pC->deferredMoveto==0 ); assert( pC->eCurType==CURTYPE_BTREE ); assert( res==0 || (res==1 && pC->isTable==0) ); testcase( res==1 ); assert( 3!=OP_Next || p->aOp[63].p4.xAdvance==sqlite3BtreeNext ); assert( 3!=OP_Prev || p->aOp[63].p4.xAdvance==sqlite3BtreePrevious ); assert( 3!=OP_NextIfOpen || p->aOp[63].p4.xAdvance==sqlite3BtreeNext ); assert( 3!=OP_PrevIfOpen || p->aOp[63].p4.xAdvance==sqlite3BtreePrevious); assert( 3!=OP_Next || 3!=OP_NextIfOpen || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found); assert( 3!=OP_Prev || 3!=OP_PrevIfOpen || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE || pC->seekOp==OP_Last ); rc = p->aOp[63].p4.xAdvance(pC->uc.pCursor, &res); next_tail63: pC->cacheStatus = CACHE_STALE; VdbeBranchTaken(res==0,2); if( rc ) goto abort_due_to_error; if( res==0 ){ pC->nullRow = 0; p->aCounter[0]++; if( db->u1.isInterrupted ) goto abort_due_to_interrupt; goto L27; }else{ pC->nullRow = 1; } if( db->u1.isInterrupted ) goto abort_due_to_interrupt; } } while(0);
L64:
do {{ assert( 17>0 && 17<=(p->nMem-p->nCursor) ); pIn1 = &aMem[17]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(64); REGISTER_TRACE(17, pIn1); goto L68; } } while(0);
L65:
do {{ goto L83; } } while(0);
L66:
do {{ pOut = out2Prerelease(p, 16); pOut->u.i = 1; } } while(0);
L67:
do {{ pIn1 = &aMem[17]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i+1]; pIn1->flags = MEM_Undefined; goto *target; } } while(0);
L68:
do {{ pIn1 = &aMem[15]; assert( pIn1->flags&MEM_Int ); VdbeBranchTaken( pIn1->u.i>0, 2); if( pIn1->u.i>0 ){ pIn1->u.i -= 0; goto L70; } } } while(0);
L69:
do {{ pIn1 = &aMem[17]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i+1]; pIn1->flags = MEM_Undefined; goto *target; } } while(0);
L70:
do {{ Mem *pMem; assert( 3>0 && 3<=(p->nMem-p->nCursor) ); pMem = &aMem[3]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[70].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L71:
do {{ Mem *pMem; assert( 4>0 && 4<=(p->nMem-p->nCursor) ); pMem = &aMem[4]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[71].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L72:
do {{ Mem *pMem; assert( 5>0 && 5<=(p->nMem-p->nCursor) ); pMem = &aMem[5]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[72].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L73:
do {{ Mem *pMem; assert( 6>0 && 6<=(p->nMem-p->nCursor) ); pMem = &aMem[6]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[73].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L74:
do {{ Mem *pMem; assert( 7>0 && 7<=(p->nMem-p->nCursor) ); pMem = &aMem[7]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[74].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L75:
do {{ Mem *pMem; assert( 8>0 && 8<=(p->nMem-p->nCursor) ); pMem = &aMem[8]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[75].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L76:
do {{ Mem *pMem; assert( 9>0 && 9<=(p->nMem-p->nCursor) ); pMem = &aMem[9]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[76].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L77:
do {{ Mem *pMem; assert( 10>0 && 10<=(p->nMem-p->nCursor) ); pMem = &aMem[10]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[77].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } } while(0);
L78:
do {{ int n; n = 9; pIn1 = &aMem[1]; pOut = &aMem[36]; assert( pOut!=pIn1 ); while( 1 ){ sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem); Deephemeralize(pOut); REGISTER_TRACE(36+9-n, pOut); if( (n--)==0 ) break; pOut++; pIn1++; } } } while(0);
L79:
do {{ Mem *pMem; int i; assert( p->nResColumn==10 ); assert( 36>0 ); assert( 36+10<=(p->nMem-p->nCursor)+1 ); if( SQLITE_OK!=(rc = sqlite3VdbeCheckFk(p, 0)) ){ assert( db->flags&SQLITE_CountRows ); assert( p->usesStmtJournal ); goto abort_due_to_error; } assert( p->iStatement==0 || db->flags&SQLITE_CountRows ); rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE); assert( rc==SQLITE_OK ); p->cacheCtr = (p->cacheCtr + 2)|1; pMem = p->pResultSet = &aMem[36]; for(i=0; i<10; i++){ assert( memIsValid(&pMem[i]) ); Deephemeralize(&pMem[i]); assert( (pMem[i].flags & MEM_Ephem)==0 || (pMem[i].flags & (MEM_Str|MEM_Blob))==0 ); sqlite3VdbeMemNulTerminate(&pMem[i]); REGISTER_TRACE(36+i, &pMem[i]); } if( db->mallocFailed ) goto no_mem; p->pc = (int)79 + 1; rc = SQLITE_ROW; goto vdbe_return; } } while(0);
L80:
do {{ pIn1 = &aMem[17]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i+1]; pIn1->flags = MEM_Undefined; goto *target; } } while(0);
L81:
do {{ int cnt; u16 nullFlag; pOut = out2Prerelease(p, 1); cnt = 14-1; assert( 14<=(p->nMem-p->nCursor) ); pOut->flags = nullFlag = 0 ? (MEM_Null|MEM_Cleared) : MEM_Null; while( cnt>0 ){ pOut++; memAboutToChange(p, pOut); sqlite3VdbeMemSetNull(pOut); pOut->flags = nullFlag; cnt--; } } } while(0);
L82:
do {{ pIn1 = &aMem[18]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i+1]; pIn1->flags = MEM_Undefined; goto *target; } } while(0);
L83:
do { if (21 == OP_Halt || (aMem[0].flags & MEM_Null)!=0 ) { const char *zType; const char *zLogFmt; VdbeFrame *pFrame; int pcx; pcx = (int)83; if( 0==SQLITE_OK && p->pFrame ){ pFrame = p->pFrame; p->pFrame = pFrame->pParent; p->nFrame--; sqlite3VdbeSetChanges(db, p->nChange); pcx = sqlite3VdbeFrameRestore(pFrame); lastRowid = db->lastRowid; if( 0==OE_Ignore ){ pcx = p->aOp[pcx].p2-1; } aMem = p->aMem; goto *labels[pcx+1]; } p->rc = 0; p->errorAction = (u8)0; p->pc = pcx; if( p->rc ){ if( 0 ){ static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK", "FOREIGN KEY" }; assert( 0>=1 && 0<=4 ); testcase( 0==1 ); testcase( 0==2 ); testcase( 0==3 ); testcase( 0==4 ); zType = azType[0-1]; }else{ zType = 0; } assert( zType!=0 || 0!=0 ); zLogFmt = "abort at %d in [%s]: %s"; if( zType && 0 ){ sqlite3VdbeError(p, "%s constraint failed: %s", zType, 0); }else if( 0 ){ sqlite3VdbeError(p, "%s", 0); }else{ sqlite3VdbeError(p, "%s constraint failed", zType); } sqlite3_log(0, zLogFmt, pcx, p->zSql, p->zErrMsg); } rc = sqlite3VdbeHalt(p); assert( rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR ); if( rc==SQLITE_BUSY ){ p->rc = rc = SQLITE_BUSY; }else{ assert( rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT ); assert( rc==SQLITE_OK || db->nDeferredCons>0 || db->nDeferredImmCons>0 ); rc = p->rc ? SQLITE_ERROR : SQLITE_DONE; } goto vdbe_return; } } while(0);
L84:
do {{ Btree *pBt; int iMeta; int iGen; assert( p->bIsReader ); assert( p->readOnly==0 || 0==0 ); assert( 0>=0 && 0<db->nDb ); assert( DbMaskTest(p->btreeMask, 0) ); if( 0 && (db->flags & SQLITE_QueryOnly)!=0 ){ rc = SQLITE_READONLY; goto abort_due_to_error; } pBt = db->aDb[0].pBt; if( pBt ){ rc = sqlite3BtreeBeginTrans(pBt, 0); testcase( rc==SQLITE_BUSY_SNAPSHOT ); testcase( rc==SQLITE_BUSY_RECOVERY ); if( (rc&0xff)==SQLITE_BUSY ){ p->pc = (int)84; p->rc = rc; goto vdbe_return; } if( rc!=SQLITE_OK ){ goto abort_due_to_error; } if( 0 && p->usesStmtJournal && (db->autoCommit==0 || db->nVdbeRead>1) ){ assert( sqlite3BtreeIsInTrans(pBt) ); if( p->iStatement==0 ){ assert( db->nStatement>=0 && db->nSavepoint>=0 ); db->nStatement++; p->iStatement = db->nSavepoint + db->nStatement; } rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN, p->iStatement-1); if( rc==SQLITE_OK ){ rc = sqlite3BtreeBeginStmt(pBt, p->iStatement); } p->nStmtDefCons = db->nDeferredCons; p->nStmtDefImmCons = db->nDeferredImmCons; } sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&iMeta); iGen = db->aDb[0].pSchema->iGeneration; }else{ iGen = iMeta = 0; } assert( 1==0 || -14==P4_INT32 ); if( 1 && (iMeta!=1 || iGen!=0) ){ sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed"); if( db->aDb[0].pSchema->schema_cookie!=iMeta ){ sqlite3ResetOneSchema(db, 0); } p->expired = 1; rc = SQLITE_SCHEMA; } if( rc ) goto abort_due_to_error; } } while(0);
L85:
do {{ u8 isWriteLock = (u8)0; if( isWriteLock || 0==(db->flags&SQLITE_ReadUncommitted) ){ int p1 = 0; assert( p1>=0 && p1<db->nDb ); assert( DbMaskTest(p->btreeMask, p1) ); assert( isWriteLock==0 || isWriteLock==1 ); rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, 2, isWriteLock); if( rc ){ if( (rc&0xFF)==SQLITE_LOCKED ){ const char *z = "lineitem"; sqlite3VdbeError(p, "database table is locked: %s", z); } goto abort_due_to_error; } } } } while(0);
L86:
do {{ assert( "1998-12-01"!=0 ); pOut = out2Prerelease(p, 24); pOut->flags = MEM_Str|MEM_Static|MEM_Term; pOut->z = "1998-12-01"; pOut->n = 10; pOut->enc = encoding; UPDATE_MAX_BLOBSIZE(pOut); if( 0 ){ assert( 0>0 ); assert( 0<=(p->nMem-p->nCursor) ); pIn3 = &aMem[0]; assert( pIn3->flags & MEM_Int ); if( pIn3->u.i ) pOut->flags = MEM_Blob|MEM_Static|MEM_Term; } } } while(0);
L87:
do {{ pOut = out2Prerelease(p, 33); pOut->u.i = 1; } } while(0);
L88:
do {{ goto L1; } } while(0);
Lend: abort_due_to_error: if( db->mallocFailed ) rc = SQLITE_NOMEM_BKPT; assert( rc ); if( p->zErrMsg==0 && rc!=SQLITE_IOERR_NOMEM ){ sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc)); } p->rc = rc; testcase( sqlite3GlobalConfig.xLog!=0 ); sqlite3_log(rc, "statement aborts: [%s] %s", p->zSql, p->zErrMsg); sqlite3VdbeHalt(p); if( rc==SQLITE_IOERR_NOMEM ) sqlite3OomFault(db); rc = SQLITE_ERROR; if( resetSchemaOnFault>0 ){ sqlite3ResetOneSchema(db, resetSchemaOnFault-1); } vdbe_return: db->lastRowid = lastRowid; testcase( nVmStep>0 ); p->aCounter[SQLITE_STMTSTATUS_VM_STEP] += (int)nVmStep; sqlite3VdbeLeave(p); assert( rc!=SQLITE_OK || nExtraDelete==0 || sqlite3_strlike("DELETE%",p->zSql,0)!=0 ); return rc; too_big: sqlite3VdbeError(p, "string or blob too big"); rc = SQLITE_TOOBIG; goto abort_due_to_error; no_mem: sqlite3OomFault(db); sqlite3VdbeError(p, "out of memory"); rc = SQLITE_NOMEM_BKPT; goto abort_due_to_error; abort_due_to_interrupt: assert( db->u1.isInterrupted ); rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT; p->rc = rc; sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc)); goto abort_due_to_error; } 
