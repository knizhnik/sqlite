#include "vdbe-gen.h"
char const* const VdbeCompiledQueryTextQ1 = "select\n    l_returnflag,\n    l_linestatus,\n    sum(l_quantity) as sum_qty,\n    sum(l_extendedprice) as sum_base_price,\n    sum(l_extendedprice*(1-l_discount)) as sum_disc_price,\n    sum(l_extendedprice*(1-l_discount)*(1+l_tax)) as sum_charge,\n    avg(l_quantity) as avg_qty,\n    avg(l_extendedprice) as avg_price,\n    avg(l_discount) as avg_disc,\n    count(*) as count_order\nfrom\n    lineitem\nwhere\n    l_shipdate <= 19981201\ngroup by\n    l_returnflag,\n    l_linestatus\norder by\n    l_returnflag,\n    l_linestatus;";
int VdbeCompiledQueryCodeQ1(Vdbe *p) {
static void* const labels[]={&&L0,&&L1,&&L2,&&L3,&&L4,&&L5,&&L6,&&L7,&&L8,&&L9,&&L10,&&L11,&&L12,&&L13,&&L14,&&L15,&&L16,&&L17,&&L18,&&L19,&&L20,&&L21,&&L22,&&L23,&&L24,&&L25,&&L26,&&L27,&&L28,&&L29,&&L30,&&L31,&&L32,&&L33,&&L34,&&L35,&&L36,&&L37,&&L38,&&L39,&&L40,&&L41,&&L42,&&L43,&&L44,&&L45,&&L46,&&L47,&&L48,&&L49,&&L50,&&L51,&&L52,&&L53,&&L54,&&L55,&&L56,&&L57,&&L58,&&L59,&&L60,&&L61,&&L62,&&L63,&&L64,&&L65,&&L66,&&L67,&&L68,&&L69,&&L70,&&L71,&&L72,&&L73,&&L74,&&L75,&&L76,&&L77,&&L78,&&L79,&&L80,&&L81,&&L82,&&L83,&&L84,&&L85,&&L86,&&L87,&&L88,&&Lend};
 void * target; int rc = SQLITE_OK; sqlite3 *db = p->db; u8 resetSchemaOnFault = 0; u8 encoding = ENC(db); int iCompare = 0; unsigned nVmStep = 0; unsigned nProgressLimit = 0; Mem *aMem = p->aMem; Mem *pIn1 = 0; Mem *pIn2 = 0; Mem *pIn3 = 0; Mem *pOut = 0; int *aPermute = 0; i64 lastRowid = db->lastRowid; assert( p->magic==VDBE_MAGIC_RUN ); sqlite3VdbeEnter(p); if( p->rc==SQLITE_NOMEM ){ goto no_mem; } assert( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_BUSY ); assert( p->bIsReader || p->readOnly!=0 ); p->rc = SQLITE_OK; p->iCurrentTime = 0; assert( p->explain==0 ); p->pResultSet = 0; db->busyHandler.nBusy = 0; if( db->u1.isInterrupted ) goto abort_due_to_interrupt; sqlite3VdbeIOTraceSql(p); 
L0:
{ if( 84 ) goto *labels[84-1]; } 
L1:

L2:
{ VdbeCursor *pCx; assert( 2>=0 ); assert( 6>=0 ); pCx = allocateCursor(p, 2, 6, -1, CURTYPE_SORTER); if( pCx==0 ) goto no_mem; pCx->pKeyInfo = p->aOp[2].p4.pKeyInfo; assert( pCx->pKeyInfo->db==db ); assert( pCx->pKeyInfo->enc==ENC(db) ); rc = sqlite3VdbeSorterInit(db, 0, pCx); if( rc ) goto abort_due_to_error; } 
L3:
{ pOut = out2Prerelease(p, 16); pOut->u.i = 0; } 
L4:
{ pOut = out2Prerelease(p, 15); pOut->u.i = 0; } 
L5:
{ int cnt; u16 nullFlag; pOut = out2Prerelease(p, 19); cnt = 20-19; assert( 20<=(p->nMem-p->nCursor) ); pOut->flags = nullFlag = 0 ? (MEM_Null|MEM_Cleared) : MEM_Null; while( cnt>0 ){ pOut++; memAboutToChange(p, pOut); sqlite3VdbeMemSetNull(pOut); pOut->flags = nullFlag; cnt--; } } 
L6:
{ assert( 18>0 && 18<=(p->nMem-p->nCursor) ); pIn1 = &aMem[18]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(6); REGISTER_TRACE(18, pIn1); goto *labels[81 - 1]; } 
L7:
{ int nField; KeyInfo *pKeyInfo; int p2; int iDb; int wrFlag; Btree *pX; VdbeCursor *pCur; Db *pDb; if (54 == OP_ReopenIdx) { assert( 0==0 || 0==OPFLAG_SEEKEQ ); assert( -14==P4_KEYINFO ); pCur = p->apCsr[0]; if( pCur && pCur->pgnoRoot==(u32)2 ){ assert( pCur->iDb==0 ); goto open_cursor_set_hints; } } assert( 54==OP_OpenWrite || 0==0 || 0==OPFLAG_SEEKEQ ); assert( p->bIsReader ); assert( 54==OP_OpenRead || 54==OP_ReopenIdx || p->readOnly==0 ); if( p->expired ){ rc = SQLITE_ABORT_ROLLBACK; goto abort_due_to_error; } nField = 0; pKeyInfo = 0; p2 = 2; iDb = 0; assert( iDb>=0 && iDb<db->nDb ); assert( DbMaskTest(p->btreeMask, iDb) ); pDb = &db->aDb[iDb]; pX = pDb->pBt; assert( pX!=0 ); if( 54==OP_OpenWrite ){ assert( OPFLAG_FORDELETE==BTREE_FORDELETE ); wrFlag = BTREE_WRCSR | (0 & OPFLAG_FORDELETE); assert( sqlite3SchemaMutexHeld(db, iDb, 0) ); if( pDb->pSchema->file_format < p->minWriteFileFormat ){ p->minWriteFileFormat = pDb->pSchema->file_format; } }else{ wrFlag = 0; } if( 0 & OPFLAG_P2ISREG ){ assert( p2>0 ); assert( p2<=(p->nMem-p->nCursor) ); pIn2 = &aMem[p2]; assert( memIsValid(pIn2) ); assert( (pIn2->flags & MEM_Int)!=0 ); sqlite3VdbeMemIntegerify(pIn2); p2 = (int)pIn2->u.i; assert( p2>=2 ); } if( -14==P4_KEYINFO ){ pKeyInfo = p->aOp[7].p4.pKeyInfo; assert( pKeyInfo->enc==ENC(db) ); assert( pKeyInfo->db==db ); nField = pKeyInfo->nField+pKeyInfo->nXField; }else if( -14==P4_INT32 ){ nField = 11; } assert( 0>=0 ); assert( nField>=0 ); testcase( nField==0 ); pCur = allocateCursor(p, 0, nField, iDb, CURTYPE_BTREE); if( pCur==0 ) goto no_mem; pCur->nullRow = 1; pCur->isOrdered = 1; pCur->pgnoRoot = p2; rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor); pCur->pKeyInfo = pKeyInfo; pCur->isTable = -14!=P4_KEYINFO; open_cursor_set_hints: assert( OPFLAG_BULKCSR==BTREE_BULKLOAD ); assert( OPFLAG_SEEKEQ==BTREE_SEEK_EQ ); testcase( 0 & OPFLAG_BULKCSR ); sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (0 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ))); if( rc ) goto abort_due_to_error; } 
L8:
{ VdbeCursor *pC; BtCursor *pCrsr; int res; if (108 != OP_Rewind) { p->aCounter[SQLITE_STMTSTATUS_SORT]++; } assert( 0>=0 && 0<p->nCursor ); pC = p->apCsr[0]; assert( pC!=0 ); assert( isSorter(pC)==(108==OP_SorterSort) ); res = 1; if( isSorter(pC) ){ rc = sqlite3VdbeSorterRewind(pC, &res); }else{ assert( pC->eCurType==CURTYPE_BTREE ); pCrsr = pC->uc.pCursor; assert( pCrsr ); rc = sqlite3BtreeFirst(pCrsr, &res); pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; } if( rc ) goto abort_due_to_error; pC->nullRow = (u8)res; assert( 24>0 && 24<p->nOp ); VdbeBranchTaken(res!=0,2); if( res ) goto *labels[24-1]; } 
L9:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 10; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 23>0 && 23<=(p->nMem-p->nCursor) ); pDest = &aMem[23]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op9_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op9_column_read_header; } if( pC->nHdrParsed<=p2 ){ op9_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[9].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op9_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op9_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(23, pDest); } 
L10:
{ int res; char affinity; u16 flags1; u16 flags3; pIn1 = &aMem[24]; pIn3 = &aMem[23]; flags1 = pIn1->flags; flags3 = pIn3->flags; if( (flags1 | flags3)&MEM_Null ){ if( 83 & SQLITE_NULLEQ ){ assert( 80==OP_Eq || 80==OP_Ne ); assert( (flags1 & MEM_Cleared)==0 ); assert( (83 & SQLITE_JUMPIFNULL)==0 ); if( (flags1&MEM_Null)!=0 && (flags3&MEM_Null)!=0 && (flags3&MEM_Cleared)==0 ){ res = 0; }else{ res = 1; } }else{ if( 83 & SQLITE_STOREP2 ){ pOut = &aMem[23]; memAboutToChange(p, pOut); MemSetTypeFlag(pOut, MEM_Null); REGISTER_TRACE(23, pOut); }else{ VdbeBranchTaken(2,3); if( 83 & SQLITE_JUMPIFNULL ){ goto *labels[23-1]; } } goto *labels[10+1]; } }else{ affinity = 83 & SQLITE_AFF_MASK; if( affinity>=SQLITE_AFF_NUMERIC ){ if( (flags1 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){ applyNumericAffinity(pIn1,0); } if( (flags3 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){ applyNumericAffinity(pIn3,0); } }else if( affinity==SQLITE_AFF_TEXT ){ if( (flags1 & MEM_Str)==0 && (flags1 & (MEM_Int|MEM_Real))!=0 ){ testcase( pIn1->flags & MEM_Int ); testcase( pIn1->flags & MEM_Real ); sqlite3VdbeMemStringify(pIn1, encoding, 1); testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) ); flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask); } if( (flags3 & MEM_Str)==0 && (flags3 & (MEM_Int|MEM_Real))!=0 ){ testcase( pIn3->flags & MEM_Int ); testcase( pIn3->flags & MEM_Real ); sqlite3VdbeMemStringify(pIn3, encoding, 1); testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) ); flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask); } } assert( -4==P4_COLLSEQ || p->aOp[10].p4.pColl==0 ); if( flags1 & MEM_Zero ){ sqlite3VdbeMemExpandBlob(pIn1); flags1 &= ~MEM_Zero; } if( flags3 & MEM_Zero ){ sqlite3VdbeMemExpandBlob(pIn3); flags3 &= ~MEM_Zero; } res = sqlite3MemCompare(pIn3, pIn1, p->aOp[10].p4.pColl); } switch( 80 ){ case OP_Eq: res = res==0; break; case OP_Ne: res = res!=0; break; case OP_Lt: res = res<0; break; case OP_Le: res = res<=0; break; case OP_Gt: res = res>0; break; default: res = res>=0; break; } assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) ); pIn1->flags = flags1; assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) ); pIn3->flags = flags3; if( 83 & SQLITE_STOREP2 ){ pOut = &aMem[23]; memAboutToChange(p, pOut); MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = res; REGISTER_TRACE(23, pOut); }else{ VdbeBranchTaken(res!=0, (83 & SQLITE_NULLEQ)?2:3); if( res ){ goto *labels[23 - 1]; } } } 
L11:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 8; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 25>0 && 25<=(p->nMem-p->nCursor) ); pDest = &aMem[25]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op11_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op11_column_read_header; } if( pC->nHdrParsed<=p2 ){ op11_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[11].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op11_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op11_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(25, pDest); } 
L12:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 9; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 26>0 && 26<=(p->nMem-p->nCursor) ); pDest = &aMem[26]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op12_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op12_column_read_header; } if( pC->nHdrParsed<=p2 ){ op12_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[12].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op12_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op12_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(26, pDest); } 
L13:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 4; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 27>0 && 27<=(p->nMem-p->nCursor) ); pDest = &aMem[27]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op13_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op13_column_read_header; } if( pC->nHdrParsed<=p2 ){ op13_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[13].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op13_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op13_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(27, pDest); } 
L14:
{ pIn1 = &aMem[27]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } 
L15:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 5; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 28>0 && 28<=(p->nMem-p->nCursor) ); pDest = &aMem[28]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op15_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op15_column_read_header; } if( pC->nHdrParsed<=p2 ){ op15_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[15].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op15_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op15_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(28, pDest); } 
L16:
{ pIn1 = &aMem[28]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } 
L17:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 6; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 29>0 && 29<=(p->nMem-p->nCursor) ); pDest = &aMem[29]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op17_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op17_column_read_header; } if( pC->nHdrParsed<=p2 ){ op17_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[17].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op17_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op17_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(29, pDest); } 
L18:
{ pIn1 = &aMem[29]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } 
L19:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[0]; p2 = 7; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 30>0 && 30<=(p->nMem-p->nCursor) ); pDest = &aMem[30]; memAboutToChange(p, pDest); assert( 0>=0 && 0<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op19_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op19_column_read_header; } if( pC->nHdrParsed<=p2 ){ op19_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[19].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op19_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op19_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(30, pDest); } 
L20:
{ pIn1 = &aMem[30]; if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } } 
L21:
{ u8 *zNewRecord; Mem *pRec; u64 nData; int nHdr; i64 nByte; i64 nZero; int nVarint; u32 serial_type; Mem *pData0; Mem *pLast; int nField; char *zAffinity; int file_format; int i; int j; u32 len; nData = 0; nHdr = 0; nZero = 0; nField = 25; zAffinity = 0; assert( nField>0 && 6>0 && 6+nField<=(p->nMem-p->nCursor)+1 ); pData0 = &aMem[nField]; nField = 6; pLast = &pData0[nField-1]; file_format = p->minWriteFileFormat; assert( 23<25 || 23>=25+6 ); pOut = &aMem[23]; memAboutToChange(p, pOut); assert( pData0<=pLast ); if( zAffinity ){ pRec = pData0; do{ applyAffinity(pRec++, *(zAffinity++), encoding); assert( zAffinity[0]==0 || pRec<=pLast ); }while( zAffinity[0] ); } pRec = pLast; do{ assert( memIsValid(pRec) ); pRec->uTemp = serial_type = sqlite3VdbeSerialType(pRec, file_format, &len); if( pRec->flags & MEM_Zero ){ if( nData ){ if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem; }else{ nZero += pRec->u.nZero; len -= pRec->u.nZero; } } nData += len; testcase( serial_type==127 ); testcase( serial_type==128 ); nHdr += serial_type<=127 ? 1 : sqlite3VarintLen(serial_type); }while( (--pRec)>=pData0 ); testcase( nHdr==126 ); testcase( nHdr==127 ); if( nHdr<=126 ){ nHdr += 1; }else{ nVarint = sqlite3VarintLen(nHdr); nHdr += nVarint; if( nVarint<sqlite3VarintLen(nHdr) ) nHdr++; } nByte = nHdr+nData; if( nByte+nZero>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } if( sqlite3VdbeMemClearAndResize(pOut, (int)nByte) ){ goto no_mem; } zNewRecord = (u8 *)pOut->z; i = putVarint32(zNewRecord, nHdr); j = nHdr; assert( pData0<=pLast ); pRec = pData0; do{ serial_type = pRec->uTemp; i += putVarint32(&zNewRecord[i], serial_type); j += sqlite3VdbeSerialPut(&zNewRecord[j], pRec, serial_type); }while( (++pRec)<=pLast ); assert( i==nHdr ); assert( j==nByte ); assert( 23>0 && 23<=(p->nMem-p->nCursor) ); pOut->n = (int)nByte; pOut->flags = MEM_Blob; if( nZero ){ pOut->u.nZero = nZero; pOut->flags |= MEM_Zero; } pOut->enc = SQLITE_UTF8; REGISTER_TRACE(23, pOut); UPDATE_MAX_BLOBSIZE(pOut); } 
L22:
{ VdbeCursor *pC; int nKey; const char *zKey; assert( 2>=0 && 2<p->nCursor ); pC = p->apCsr[2]; assert( pC!=0 ); assert( isSorter(pC)==(109==OP_SorterInsert) ); pIn2 = &aMem[23]; assert( pIn2->flags & MEM_Blob ); if( 0 & OPFLAG_NCHANGE ) p->nChange++; assert( pC->eCurType==CURTYPE_BTREE || 109==OP_SorterInsert ); assert( pC->isTable==0 ); rc = ExpandBlob(pIn2); if( rc ) goto abort_due_to_error; if( 109==OP_SorterInsert ){ rc = sqlite3VdbeSorterWrite(pC, pIn2); }else{ nKey = pIn2->n; zKey = pIn2->z; rc = sqlite3BtreeInsert(pC->uc.pCursor, zKey, nKey, "", 0, 0, 0, ((0 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0) ); assert( pC->deferredMoveto==0 ); pC->cacheStatus = CACHE_STALE; } if( rc) goto abort_due_to_error; } 
L23:
{ VdbeCursor *pC; int res; switch (7) { case OP_SorterNext: pC = p->apCsr[0]; assert( isSorter(pC) ); res = 0; rc = sqlite3VdbeSorterNext(db, pC, &res); goto next_tail23; case OP_PrevIfOpen: case OP_NextIfOpen: if( p->apCsr[0]==0 ) break; case OP_Prev: case OP_Next: assert( 0>=0 && 0<p->nCursor ); assert( 1<ArraySize(p->aCounter) ); pC = p->apCsr[0]; res = 0; assert( pC!=0 ); assert( pC->deferredMoveto==0 ); assert( pC->eCurType==CURTYPE_BTREE ); assert( res==0 || (res==1 && pC->isTable==0) ); testcase( res==1 ); assert( 7!=OP_Next || p->aOp[23].p4.xAdvance==sqlite3BtreeNext ); assert( 7!=OP_Prev || p->aOp[23].p4.xAdvance==sqlite3BtreePrevious ); assert( 7!=OP_NextIfOpen || p->aOp[23].p4.xAdvance==sqlite3BtreeNext ); assert( 7!=OP_PrevIfOpen || p->aOp[23].p4.xAdvance==sqlite3BtreePrevious); assert( 7!=OP_Next || 7!=OP_NextIfOpen || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found); assert( 7!=OP_Prev || 7!=OP_PrevIfOpen || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE || pC->seekOp==OP_Last ); rc = p->aOp[23].p4.xAdvance(pC->uc.pCursor, &res); next_tail23: pC->cacheStatus = CACHE_STALE; VdbeBranchTaken(res==0,2); if( rc ) goto abort_due_to_error; if( res==0 ){ pC->nullRow = 0; p->aCounter[1]++; if( db->u1.isInterrupted ) goto abort_due_to_interrupt; goto *labels[9-1]; }else{ pC->nullRow = 1; } if( db->u1.isInterrupted ) goto abort_due_to_interrupt; } } 
L24:
{ assert( 0>=0 && 0<p->nCursor ); sqlite3VdbeFreeCursor(p, p->apCsr[0]); p->apCsr[0] = 0; } 
L25:
{ VdbeCursor *pCx; assert( 3>=0 ); assert( 6>=0 ); pCx = allocateCursor(p, 3, 6, -1, CURTYPE_PSEUDO); if( pCx==0 ) goto no_mem; pCx->nullRow = 1; pCx->uc.pseudoTableReg = 23; pCx->isTable = 1; assert( 0==0 ); } 
L26:
{ VdbeCursor *pC; BtCursor *pCrsr; int res; if (106 != OP_Rewind) { p->aCounter[SQLITE_STMTSTATUS_SORT]++; } assert( 2>=0 && 2<p->nCursor ); pC = p->apCsr[2]; assert( pC!=0 ); assert( isSorter(pC)==(106==OP_SorterSort) ); res = 1; if( isSorter(pC) ){ rc = sqlite3VdbeSorterRewind(pC, &res); }else{ assert( pC->eCurType==CURTYPE_BTREE ); pCrsr = pC->uc.pCursor; assert( pCrsr ); rc = sqlite3BtreeFirst(pCrsr, &res); pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; } if( rc ) goto abort_due_to_error; pC->nullRow = (u8)res; assert( 83>0 && 83<p->nOp ); VdbeBranchTaken(res!=0,2); if( res ) goto *labels[83-1]; } 
L27:
{ VdbeCursor *pC; pOut = &aMem[23]; pC = p->apCsr[2]; assert( isSorter(pC) ); rc = sqlite3VdbeSorterRowkey(pC, pOut); assert( rc!=SQLITE_OK || (pOut->flags & MEM_Blob) ); assert( 2>=0 && 2<p->nCursor ); if( rc ) goto abort_due_to_error; p->apCsr[3]->cacheStatus = CACHE_STALE; } 
L28:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 0; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 21>0 && 21<=(p->nMem-p->nCursor) ); pDest = &aMem[21]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op28_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op28_column_read_header; } if( pC->nHdrParsed<=p2 ){ op28_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[28].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op28_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op28_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(21, pDest); } 
L29:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 1; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 22>0 && 22<=(p->nMem-p->nCursor) ); pDest = &aMem[22]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op29_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op29_column_read_header; } if( pC->nHdrParsed<=p2 ){ op29_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[29].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op29_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op29_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(22, pDest); } 
L30:
{ int n; int i; int p1; int p2; const KeyInfo *pKeyInfo; int idx; CollSeq *pColl; int bRev; if( (0 & OPFLAG_PERMUTE)==0 ) aPermute = 0; n = 2; pKeyInfo = p->aOp[30].p4.pKeyInfo; assert( n>0 ); assert( pKeyInfo!=0 ); p1 = 19; p2 = 21; for(i=0; i<n; i++){ idx = aPermute ? aPermute[i] : i; assert( memIsValid(&aMem[p1+idx]) ); assert( memIsValid(&aMem[p2+idx]) ); REGISTER_TRACE(p1+idx, &aMem[p1+idx]); REGISTER_TRACE(p2+idx, &aMem[p2+idx]); assert( i<pKeyInfo->nField ); pColl = pKeyInfo->aColl[i]; bRev = pKeyInfo->aSortOrder[i]; iCompare = sqlite3MemCompare(&aMem[p1+idx], &aMem[p2+idx], pColl); if( iCompare ){ if( bRev ) iCompare = -iCompare; break; } } aPermute = 0; } 
L31:
{ if( iCompare<0 ){ VdbeBranchTaken(0,3); goto *labels[32 - 1]; }else if( iCompare==0 ){ VdbeBranchTaken(1,3); goto *labels[36 - 1]; }else{ VdbeBranchTaken(2,3); goto *labels[32 - 1]; } } 
L32:
{ int n; int p1; int p2; n = 2; p1 = 21; p2 = 19; assert( n>0 && p1>0 && p2>0 ); assert( p1+n<=p2 || p2+n<=p1 ); pIn1 = &aMem[p1]; pOut = &aMem[p2]; do{ assert( pOut<=&aMem[(p->nMem-p->nCursor)] ); assert( pIn1<=&aMem[(p->nMem-p->nCursor)] ); assert( memIsValid(pIn1) ); memAboutToChange(p, pOut); sqlite3VdbeMemMove(pOut, pIn1); Deephemeralize(pOut); REGISTER_TRACE(p2++, pOut); pIn1++; pOut++; }while( --n ); } 
L33:
{ assert( 17>0 && 17<=(p->nMem-p->nCursor) ); pIn1 = &aMem[17]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(33); REGISTER_TRACE(17, pIn1); goto *labels[68 - 1]; } 
L34:
{ pIn1 = &aMem[16]; assert( pIn1->flags&MEM_Int ); VdbeBranchTaken( pIn1->u.i>0, 2); if( pIn1->u.i>0 ){ pIn1->u.i -= 0; goto *labels[83-1]; } } 
L35:
{ assert( 18>0 && 18<=(p->nMem-p->nCursor) ); pIn1 = &aMem[18]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(35); REGISTER_TRACE(18, pIn1); goto *labels[81 - 1]; } 
L36:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 2; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 25>0 && 25<=(p->nMem-p->nCursor) ); pDest = &aMem[25]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op36_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op36_column_read_header; } if( pC->nHdrParsed<=p2 ){ op36_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[36].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op36_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op36_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(25, pDest); } 
L37:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[37]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 3>0 && 3<=(p->nMem-p->nCursor) ); assert( n==0 || (25>0 && 25+n<=(p->nMem-p->nCursor)+1) ); assert( 3<25 || 3>=25+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)37; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[3]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[25+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[37-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L38:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 3; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 26>0 && 26<=(p->nMem-p->nCursor) ); pDest = &aMem[26]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op38_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op38_column_read_header; } if( pC->nHdrParsed<=p2 ){ op38_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[38].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op38_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op38_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(26, pDest); } 
L39:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[39]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 4>0 && 4<=(p->nMem-p->nCursor) ); assert( n==0 || (26>0 && 26+n<=(p->nMem-p->nCursor)+1) ); assert( 4<26 || 4>=26+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)39; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[4]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[26+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[39-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L40:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 3; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 31>0 && 31<=(p->nMem-p->nCursor) ); pDest = &aMem[31]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op40_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op40_column_read_header; } if( pC->nHdrParsed<=p2 ){ op40_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[40].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op40_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op40_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(31, pDest); } 
L41:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 4; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 34>0 && 34<=(p->nMem-p->nCursor) ); pDest = &aMem[34]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op41_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op41_column_read_header; } if( pC->nHdrParsed<=p2 ){ op41_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[41].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op41_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op41_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(34, pDest); } 
L42:
{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[34]; type1 = numericType(pIn1); pIn2 = &aMem[33]; type2 = numericType(pIn2); pOut = &aMem[32]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null42; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 90 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp42_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp42_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp42_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null42; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp42_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null42; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp42_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 90 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null42; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null42; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null42; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } arithmetic_result_is_null42: sqlite3VdbeMemSetNull(pOut); } 
L43:
{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[32]; type1 = numericType(pIn1); pIn2 = &aMem[31]; type2 = numericType(pIn2); pOut = &aMem[27]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null43; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 91 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp43_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp43_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp43_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null43; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp43_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null43; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp43_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 91 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null43; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null43; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null43; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } arithmetic_result_is_null43: sqlite3VdbeMemSetNull(pOut); } 
L44:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[44]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 5>0 && 5<=(p->nMem-p->nCursor) ); assert( n==0 || (27>0 && 27+n<=(p->nMem-p->nCursor)+1) ); assert( 5<27 || 5>=27+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)44; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[5]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[27+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[44-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L45:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 3; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 31>0 && 31<=(p->nMem-p->nCursor) ); pDest = &aMem[31]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op45_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op45_column_read_header; } if( pC->nHdrParsed<=p2 ){ op45_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[45].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op45_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op45_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(31, pDest); } 
L46:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 4; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 35>0 && 35<=(p->nMem-p->nCursor) ); pDest = &aMem[35]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op46_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op46_column_read_header; } if( pC->nHdrParsed<=p2 ){ op46_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[46].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op46_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op46_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(35, pDest); } 
L47:
{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[35]; type1 = numericType(pIn1); pIn2 = &aMem[33]; type2 = numericType(pIn2); pOut = &aMem[34]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null47; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 90 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp47_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp47_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp47_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null47; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp47_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null47; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp47_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 90 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null47; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null47; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null47; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } arithmetic_result_is_null47: sqlite3VdbeMemSetNull(pOut); } 
L48:
{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[34]; type1 = numericType(pIn1); pIn2 = &aMem[31]; type2 = numericType(pIn2); pOut = &aMem[32]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null48; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 91 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp48_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp48_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp48_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null48; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp48_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null48; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp48_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 91 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null48; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null48; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null48; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } arithmetic_result_is_null48: sqlite3VdbeMemSetNull(pOut); } 
L49:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 5; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 31>0 && 31<=(p->nMem-p->nCursor) ); pDest = &aMem[31]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op49_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op49_column_read_header; } if( pC->nHdrParsed<=p2 ){ op49_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[49].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op49_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op49_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(31, pDest); } 
L50:
{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[31]; type1 = numericType(pIn1); pIn2 = &aMem[33]; type2 = numericType(pIn2); pOut = &aMem[34]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null50; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 89 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp50_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp50_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp50_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null50; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp50_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null50; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp50_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 89 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null50; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null50; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null50; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } arithmetic_result_is_null50: sqlite3VdbeMemSetNull(pOut); } 
L51:
{ char bIntint; u16 flags; u16 type1; u16 type2; i64 iA; i64 iB; double rA; double rB; pIn1 = &aMem[34]; type1 = numericType(pIn1); pIn2 = &aMem[32]; type2 = numericType(pIn2); pOut = &aMem[28]; flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null51; if( (type1 & type2 & MEM_Int)!=0 ){ iA = pIn1->u.i; iB = pIn2->u.i; bIntint = 1; switch( 91 ){ case OP_Add: if( sqlite3AddInt64(&iB,iA) ) goto fp51_math; break; case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp51_math; break; case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp51_math; break; case OP_Divide: { if( iA==0 ) goto arithmetic_result_is_null51; if( iA==-1 && iB==SMALLEST_INT64 ) goto fp51_math; iB /= iA; break; } default: { if( iA==0 ) goto arithmetic_result_is_null51; if( iA==-1 ) iA = 1; iB %= iA; break; } } pOut->u.i = iB; MemSetTypeFlag(pOut, MEM_Int); }else{ bIntint = 0; fp51_math: rA = sqlite3VdbeRealValue(pIn1); rB = sqlite3VdbeRealValue(pIn2); switch( 91 ){ case OP_Add: rB += rA; break; case OP_Subtract: rB -= rA; break; case OP_Multiply: rB *= rA; break; case OP_Divide: { if( rA==(double)0 ) goto arithmetic_result_is_null51; rB /= rA; break; } default: { iA = (i64)rA; iB = (i64)rB; if( iA==0 ) goto arithmetic_result_is_null51; if( iA==-1 ) iA = 1; rB = (double)(iB % iA); break; } } if( sqlite3IsNaN(rB) ){ goto arithmetic_result_is_null51; } pOut->u.r = rB; MemSetTypeFlag(pOut, MEM_Real); if( ((type1|type2)&MEM_Real)==0 && !bIntint ){ sqlite3VdbeIntegerAffinity(pOut); } } arithmetic_result_is_null51: sqlite3VdbeMemSetNull(pOut); } 
L52:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[52]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 6>0 && 6<=(p->nMem-p->nCursor) ); assert( n==0 || (28>0 && 28+n<=(p->nMem-p->nCursor)+1) ); assert( 6<28 || 6>=28+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)52; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[6]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[28+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[52-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L53:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 2; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 29>0 && 29<=(p->nMem-p->nCursor) ); pDest = &aMem[29]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op53_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op53_column_read_header; } if( pC->nHdrParsed<=p2 ){ op53_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[53].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op53_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op53_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(29, pDest); } 
L54:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[54]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 7>0 && 7<=(p->nMem-p->nCursor) ); assert( n==0 || (29>0 && 29+n<=(p->nMem-p->nCursor)+1) ); assert( 7<29 || 7>=29+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)54; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[7]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[29+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[54-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L55:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 3; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 30>0 && 30<=(p->nMem-p->nCursor) ); pDest = &aMem[30]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op55_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op55_column_read_header; } if( pC->nHdrParsed<=p2 ){ op55_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[55].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op55_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op55_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(30, pDest); } 
L56:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[56]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 8>0 && 8<=(p->nMem-p->nCursor) ); assert( n==0 || (30>0 && 30+n<=(p->nMem-p->nCursor)+1) ); assert( 8<30 || 8>=30+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)56; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[8]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[30+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[56-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L57:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 4; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 30>0 && 30<=(p->nMem-p->nCursor) ); pDest = &aMem[30]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op57_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op57_column_read_header; } if( pC->nHdrParsed<=p2 ){ op57_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[57].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op57_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op57_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(30, pDest); } 
L58:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[58]; if ( op->p4type==P4_FUNCDEF ) { n = 1; assert( 9>0 && 9<=(p->nMem-p->nCursor) ); assert( n==0 || (30>0 && 30+n<=(p->nMem-p->nCursor)+1) ); assert( 9<30 || 9>=30+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)58; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[9]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[30+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[58-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L59:
{ int n; int i; sqlite3_context *pCtx; Mem *pMem; Mem t; Op *op = &p->aOp[59]; if ( op->p4type==P4_FUNCDEF ) { n = 0; assert( 10>0 && 10<=(p->nMem-p->nCursor) ); assert( n==0 || (0>0 && 0+n<=(p->nMem-p->nCursor)+1) ); assert( 10<0 || 10>=0+n ); pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*)); if( pCtx==0 ) goto no_mem; pCtx->pMem = 0; pCtx->pFunc = op->p4.pFunc; pCtx->iOp = (int)59; pCtx->pVdbe = p; pCtx->argc = n; op->p4.pCtx = pCtx; op->p4type==P4_FUNCCTX; } else { assert( op->p4type==P4_FUNCCTX ); pCtx = op->p4.pCtx; } pMem = &aMem[10]; if( pCtx->pMem != pMem ){ pCtx->pMem = pMem; for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[0+i]; } pMem->n++; sqlite3VdbeMemInit(&t, db, MEM_Null); pCtx->pOut = &t; pCtx->fErrorOrAux = 0; pCtx->skipFlag = 0; (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); if( pCtx->fErrorOrAux ){ if( pCtx->isError ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(&t)); rc = pCtx->isError; } sqlite3VdbeMemRelease(&t); if( rc ) goto abort_due_to_error; }else{ assert( t.flags==MEM_Null ); } if( pCtx->skipFlag ){ assert( pOp[-1].opcode==OP_CollSeq ); i = p->aOp[59-1].p1; if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1); } } 
L60:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 0; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 1>0 && 1<=(p->nMem-p->nCursor) ); pDest = &aMem[1]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op60_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op60_column_read_header; } if( pC->nHdrParsed<=p2 ){ op60_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[60].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op60_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op60_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(1, pDest); } 
L61:
{ i64 payloadSize64; int p2; VdbeCursor *pC; BtCursor *pCrsr; u32 *aOffset; int len; int i; Mem *pDest; Mem sMem; const u8 *zData; const u8 *zHdr; const u8 *zEndHdr; u32 offset; u64 offset64; u32 avail; u32 t; Mem *pReg; pC = p->apCsr[3]; p2 = 1; rc = sqlite3VdbeCursorMoveto(&pC, &p2); assert( 2>0 && 2<=(p->nMem-p->nCursor) ); pDest = &aMem[2]; memAboutToChange(p, pDest); assert( 3>=0 && 3<p->nCursor ); assert( pC!=0 ); assert( p2<pC->nField ); aOffset = pC->aOffset; assert( pC->eCurType!=CURTYPE_VTAB ); assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow ); assert( pC->eCurType!=CURTYPE_SORTER ); pCrsr = pC->uc.pCursor; if( rc ) goto abort_due_to_error; if( pC->cacheStatus!=p->cacheCtr ){ if( pC->nullRow ){ if( pC->eCurType==CURTYPE_PSEUDO ){ assert( pC->uc.pseudoTableReg>0 ); pReg = &aMem[pC->uc.pseudoTableReg]; assert( pReg->flags & MEM_Blob ); assert( memIsValid(pReg) ); pC->payloadSize = pC->szRow = avail = pReg->n; pC->aRow = (u8*)pReg->z; }else{ sqlite3VdbeMemSetNull(pDest); goto op61_column_out; } }else{ assert( pC->eCurType==CURTYPE_BTREE ); assert( pCrsr ); if( pC->isTable==0 ){ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64); assert( rc==SQLITE_OK ); assert( (payloadSize64 & SQLITE_MAX_U32)==(u64)payloadSize64 ); pC->aRow = sqlite3BtreeKeyFetch(pCrsr, &avail); pC->payloadSize = (u32)payloadSize64; }else{ assert( sqlite3BtreeCursorIsValid(pCrsr) ); VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &pC->payloadSize); assert( rc==SQLITE_OK ); pC->aRow = sqlite3BtreeDataFetch(pCrsr, &avail); } assert( avail<=65536 ); if( pC->payloadSize <= (u32)avail ){ pC->szRow = pC->payloadSize; }else if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; }else{ pC->szRow = avail; } } pC->cacheStatus = p->cacheCtr; pC->iHdrOffset = getVarint32(pC->aRow, offset); pC->nHdrParsed = 0; aOffset[0] = offset; if( avail<offset ){ pC->aRow = 0; pC->szRow = 0; if( offset > 98307 || offset > pC->payloadSize ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( pC->nHdrParsed<=p2 ); goto op61_column_read_header; } if( pC->nHdrParsed<=p2 ){ op61_column_read_header: if( pC->iHdrOffset<aOffset[0] ){ if( pC->aRow==0 ){ memset(&sMem, 0, sizeof(sMem)); rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem); if( rc!=SQLITE_OK ) goto abort_due_to_error; zData = (u8*)sMem.z; }else{ zData = pC->aRow; } i = pC->nHdrParsed; offset64 = aOffset[i]; zHdr = zData + pC->iHdrOffset; zEndHdr = zData + aOffset[0]; assert( i<=p2 && zHdr<zEndHdr ); do{ if( (t = zHdr[0])<0x80 ){ zHdr++; offset64 += sqlite3VdbeOneByteSerialTypeLen(t); }else{ zHdr += sqlite3GetVarint32(zHdr, &t); offset64 += sqlite3VdbeSerialTypeLen(t); } pC->aType[i++] = t; aOffset[i] = (u32)(offset64 & 0xffffffff); }while( i<=p2 && zHdr<zEndHdr ); pC->nHdrParsed = i; pC->iHdrOffset = (u32)(zHdr - zData); if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem); if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize)) || (offset64 > pC->payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } }else{ t = 0; } if( pC->nHdrParsed<=p2 ){ if( 0==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, p->aOp[61].p4.pMem, MEM_Static); }else{ sqlite3VdbeMemSetNull(pDest); } goto op61_column_out; } }else{ t = pC->aType[p2]; } assert( p2<pC->nHdrParsed ); assert( rc==SQLITE_OK ); assert( sqlite3VdbeCheckMemInvariants(pDest) ); if( VdbeMemDynamic(pDest) ) sqlite3VdbeMemSetNull(pDest); assert( t==pC->aType[p2] ); pDest->enc = encoding; if( pC->szRow>=aOffset[p2+1] ){ zData = pC->aRow + aOffset[p2]; if( t<12 ){ sqlite3VdbeSerialGet(zData, t, pDest); }else{ static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term }; pDest->n = len = (t-12)/2; if( pDest->szMalloc < len+2 ){ pDest->flags = MEM_Null; if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem; }else{ pDest->z = pDest->zMalloc; } memcpy(pDest->z, zData, len); pDest->z[len] = 0; pDest->z[len+1] = 0; pDest->flags = aFlag[t&1]; } }else{ if( ((0 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0 && ((t>=12 && (t&1)==0) || (0 & OPFLAG_TYPEOFARG)!=0)) || (len = sqlite3VdbeSerialTypeLen(t))==0 ){ static u8 aZero[8]; sqlite3VdbeSerialGet(aZero, t, pDest); }else{ rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, !pC->isTable, pDest); if( rc==SQLITE_OK ){ sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest); pDest->flags &= ~MEM_Ephem; } } } op61_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(2, pDest); } 
L62:
{ pOut = out2Prerelease(p, 15); pOut->u.i = 1; } 
L63:
{ VdbeCursor *pC; int res; switch (3) { case OP_SorterNext: pC = p->apCsr[2]; assert( isSorter(pC) ); res = 0; rc = sqlite3VdbeSorterNext(db, pC, &res); goto next_tail63; case OP_PrevIfOpen: case OP_NextIfOpen: if( p->apCsr[2]==0 ) break; case OP_Prev: case OP_Next: assert( 2>=0 && 2<p->nCursor ); assert( 0<ArraySize(p->aCounter) ); pC = p->apCsr[2]; res = 0; assert( pC!=0 ); assert( pC->deferredMoveto==0 ); assert( pC->eCurType==CURTYPE_BTREE ); assert( res==0 || (res==1 && pC->isTable==0) ); testcase( res==1 ); assert( 3!=OP_Next || p->aOp[63].p4.xAdvance==sqlite3BtreeNext ); assert( 3!=OP_Prev || p->aOp[63].p4.xAdvance==sqlite3BtreePrevious ); assert( 3!=OP_NextIfOpen || p->aOp[63].p4.xAdvance==sqlite3BtreeNext ); assert( 3!=OP_PrevIfOpen || p->aOp[63].p4.xAdvance==sqlite3BtreePrevious); assert( 3!=OP_Next || 3!=OP_NextIfOpen || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found); assert( 3!=OP_Prev || 3!=OP_PrevIfOpen || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE || pC->seekOp==OP_Last ); rc = p->aOp[63].p4.xAdvance(pC->uc.pCursor, &res); next_tail63: pC->cacheStatus = CACHE_STALE; VdbeBranchTaken(res==0,2); if( rc ) goto abort_due_to_error; if( res==0 ){ pC->nullRow = 0; p->aCounter[0]++; if( db->u1.isInterrupted ) goto abort_due_to_interrupt; goto *labels[27-1]; }else{ pC->nullRow = 1; } if( db->u1.isInterrupted ) goto abort_due_to_interrupt; } } 
L64:
{ assert( 17>0 && 17<=(p->nMem-p->nCursor) ); pIn1 = &aMem[17]; assert( VdbeMemDynamic(pIn1)==0 ); memAboutToChange(p, pIn1); pIn1->flags = MEM_Int; pIn1->u.i = (int)(64); REGISTER_TRACE(17, pIn1); goto *labels[68 - 1]; } 
L65:
{ goto *labels[83 - 1]; } 
L66:
{ pOut = out2Prerelease(p, 16); pOut->u.i = 1; } 
L67:
{ pIn1 = &aMem[17]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i]; pIn1->flags = MEM_Undefined; goto *target; } 
L68:
{ pIn1 = &aMem[15]; assert( pIn1->flags&MEM_Int ); VdbeBranchTaken( pIn1->u.i>0, 2); if( pIn1->u.i>0 ){ pIn1->u.i -= 0; goto *labels[70-1]; } } 
L69:
{ pIn1 = &aMem[17]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i]; pIn1->flags = MEM_Undefined; goto *target; } 
L70:
{ Mem *pMem; assert( 3>0 && 3<=(p->nMem-p->nCursor) ); pMem = &aMem[3]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[70].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L71:
{ Mem *pMem; assert( 4>0 && 4<=(p->nMem-p->nCursor) ); pMem = &aMem[4]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[71].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L72:
{ Mem *pMem; assert( 5>0 && 5<=(p->nMem-p->nCursor) ); pMem = &aMem[5]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[72].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L73:
{ Mem *pMem; assert( 6>0 && 6<=(p->nMem-p->nCursor) ); pMem = &aMem[6]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[73].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L74:
{ Mem *pMem; assert( 7>0 && 7<=(p->nMem-p->nCursor) ); pMem = &aMem[7]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[74].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L75:
{ Mem *pMem; assert( 8>0 && 8<=(p->nMem-p->nCursor) ); pMem = &aMem[8]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[75].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L76:
{ Mem *pMem; assert( 9>0 && 9<=(p->nMem-p->nCursor) ); pMem = &aMem[9]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[76].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L77:
{ Mem *pMem; assert( 10>0 && 10<=(p->nMem-p->nCursor) ); pMem = &aMem[10]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, p->aOp[77].p4.pFunc); if( rc ){ sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } } 
L78:
{ int n; n = 9; pIn1 = &aMem[1]; pOut = &aMem[36]; assert( pOut!=pIn1 ); while( 1 ){ sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem); Deephemeralize(pOut); REGISTER_TRACE(36+9-n, pOut); if( (n--)==0 ) break; pOut++; pIn1++; } } 
L79:
{ Mem *pMem; int i; assert( p->nResColumn==10 ); assert( 36>0 ); assert( 36+10<=(p->nMem-p->nCursor)+1 ); if( SQLITE_OK!=(rc = sqlite3VdbeCheckFk(p, 0)) ){ assert( db->flags&SQLITE_CountRows ); assert( p->usesStmtJournal ); goto abort_due_to_error; } assert( p->iStatement==0 || db->flags&SQLITE_CountRows ); rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE); assert( rc==SQLITE_OK ); p->cacheCtr = (p->cacheCtr + 2)|1; pMem = p->pResultSet = &aMem[36]; for(i=0; i<10; i++){ assert( memIsValid(&pMem[i]) ); Deephemeralize(&pMem[i]); assert( (pMem[i].flags & MEM_Ephem)==0 || (pMem[i].flags & (MEM_Str|MEM_Blob))==0 ); sqlite3VdbeMemNulTerminate(&pMem[i]); REGISTER_TRACE(36+i, &pMem[i]); } if( db->mallocFailed ) goto no_mem; p->pc = (int)79 + 1; rc = SQLITE_ROW; goto vdbe_return; } 
L80:
{ pIn1 = &aMem[17]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i]; pIn1->flags = MEM_Undefined; goto *target; } 
L81:
{ int cnt; u16 nullFlag; pOut = out2Prerelease(p, 1); cnt = 14-1; assert( 14<=(p->nMem-p->nCursor) ); pOut->flags = nullFlag = 0 ? (MEM_Null|MEM_Cleared) : MEM_Null; while( cnt>0 ){ pOut++; memAboutToChange(p, pOut); sqlite3VdbeMemSetNull(pOut); pOut->flags = nullFlag; cnt--; } } 
L82:
{ pIn1 = &aMem[18]; assert( pIn1->flags==MEM_Int ); target = labels[pIn1->u.i]; pIn1->flags = MEM_Undefined; goto *target; } 
L83:
 if (21 == OP_Halt || (aMem[0].flags & MEM_Null)!=0 ) { const char *zType; const char *zLogFmt; VdbeFrame *pFrame; int pcx; pcx = (int)83; if( 0==SQLITE_OK && p->pFrame ){ pFrame = p->pFrame; p->pFrame = pFrame->pParent; p->nFrame--; sqlite3VdbeSetChanges(db, p->nChange); pcx = sqlite3VdbeFrameRestore(pFrame); lastRowid = db->lastRowid; if( 0==OE_Ignore ){ pcx = p->aOp[pcx].p2-1; } aMem = p->aMem; goto *labels[pcx]; } p->rc = 0; p->errorAction = (u8)0; p->pc = pcx; if( p->rc ){ if( 0 ){ static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK", "FOREIGN KEY" }; assert( 0>=1 && 0<=4 ); testcase( 0==1 ); testcase( 0==2 ); testcase( 0==3 ); testcase( 0==4 ); zType = azType[0-1]; }else{ zType = 0; } assert( zType!=0 || 0!=0 ); zLogFmt = "abort at %d in [%s]: %s"; if( zType && 0 ){ sqlite3VdbeError(p, "%s constraint failed: %s", zType, 0); }else if( 0 ){ sqlite3VdbeError(p, "%s", 0); }else{ sqlite3VdbeError(p, "%s constraint failed", zType); } sqlite3_log(0, zLogFmt, pcx, p->zSql, p->zErrMsg); } rc = sqlite3VdbeHalt(p); assert( rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR ); if( rc==SQLITE_BUSY ){ p->rc = rc = SQLITE_BUSY; }else{ assert( rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT ); assert( rc==SQLITE_OK || db->nDeferredCons>0 || db->nDeferredImmCons>0 ); rc = p->rc ? SQLITE_ERROR : SQLITE_DONE; } goto vdbe_return; } 
L84:
{ Btree *pBt; int iMeta; int iGen; assert( p->bIsReader ); assert( p->readOnly==0 || 0==0 ); assert( 0>=0 && 0<db->nDb ); assert( DbMaskTest(p->btreeMask, 0) ); if( 0 && (db->flags & SQLITE_QueryOnly)!=0 ){ rc = SQLITE_READONLY; goto abort_due_to_error; } pBt = db->aDb[0].pBt; if( pBt ){ rc = sqlite3BtreeBeginTrans(pBt, 0); testcase( rc==SQLITE_BUSY_SNAPSHOT ); testcase( rc==SQLITE_BUSY_RECOVERY ); if( (rc&0xff)==SQLITE_BUSY ){ p->pc = (int)84; p->rc = rc; goto vdbe_return; } if( rc!=SQLITE_OK ){ goto abort_due_to_error; } if( 0 && p->usesStmtJournal && (db->autoCommit==0 || db->nVdbeRead>1) ){ assert( sqlite3BtreeIsInTrans(pBt) ); if( p->iStatement==0 ){ assert( db->nStatement>=0 && db->nSavepoint>=0 ); db->nStatement++; p->iStatement = db->nSavepoint + db->nStatement; } rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN, p->iStatement-1); if( rc==SQLITE_OK ){ rc = sqlite3BtreeBeginStmt(pBt, p->iStatement); } p->nStmtDefCons = db->nDeferredCons; p->nStmtDefImmCons = db->nDeferredImmCons; } sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&iMeta); iGen = db->aDb[0].pSchema->iGeneration; }else{ iGen = iMeta = 0; } assert( 1==0 || -14==P4_INT32 ); if( 1 && (iMeta!=1 || iGen!=0) ){ sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed"); if( db->aDb[0].pSchema->schema_cookie!=iMeta ){ sqlite3ResetOneSchema(db, 0); } p->expired = 1; rc = SQLITE_SCHEMA; } if( rc ) goto abort_due_to_error; } 
L85:
{ u8 isWriteLock = (u8)0; if( isWriteLock || 0==(db->flags&SQLITE_ReadUncommitted) ){ int p1 = 0; assert( p1>=0 && p1<db->nDb ); assert( DbMaskTest(p->btreeMask, p1) ); assert( isWriteLock==0 || isWriteLock==1 ); rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, 2, isWriteLock); if( rc ){ if( (rc&0xFF)==SQLITE_LOCKED ){ const char *z = "lineitem"; sqlite3VdbeError(p, "database table is locked: %s", z); } goto abort_due_to_error; } } } 
L86:
{ pOut = out2Prerelease(p, 24); pOut->u.i = 19981201; } 
L87:
{ pOut = out2Prerelease(p, 33); pOut->u.i = 1; } 
L88:
{ goto *labels[1 - 1]; } 
Lend: abort_due_to_error: if( db->mallocFailed ) rc = SQLITE_NOMEM_BKPT; assert( rc ); if( p->zErrMsg==0 && rc!=SQLITE_IOERR_NOMEM ){ sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc)); } p->rc = rc; testcase( sqlite3GlobalConfig.xLog!=0 ); sqlite3_log(rc, "statement aborts: [%s] %s", p->zSql, p->zErrMsg); sqlite3VdbeHalt(p); if( rc==SQLITE_IOERR_NOMEM ) sqlite3OomFault(db); rc = SQLITE_ERROR; if( resetSchemaOnFault>0 ){ sqlite3ResetOneSchema(db, resetSchemaOnFault-1); } vdbe_return: db->lastRowid = lastRowid; testcase( nVmStep>0 ); p->aCounter[SQLITE_STMTSTATUS_VM_STEP] += (int)nVmStep; sqlite3VdbeLeave(p); assert( rc!=SQLITE_OK || nExtraDelete==0 || sqlite3_strlike("DELETE%",p->zSql,0)!=0 ); return rc; too_big: sqlite3VdbeError(p, "string or blob too big"); rc = SQLITE_TOOBIG; goto abort_due_to_error; no_mem: sqlite3OomFault(db); sqlite3VdbeError(p, "out of memory"); rc = SQLITE_NOMEM_BKPT; goto abort_due_to_error; abort_due_to_interrupt: assert( db->u1.isInterrupted ); rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT; p->rc = rc; sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc)); goto abort_due_to_error; } 
